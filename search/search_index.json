{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-session\n\n\n\n\n\n\nThis library provides session handling middleware for PSR-7 applications, using\nan adapter-based approach that will allow usage of ext-session, JWT, or other\napproaches.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-session\n\n\n\nHowever, the package is not immediately useful unless you have a persistence\nadapter. If you are okay with using ext-session, you can install the following\npackage as well:\n\n\n$ composer require zendframework/zend-expressive-session-ext\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "zend-expressive-session"
        },
        {
            "location": "/#zend-expressive-session",
            "text": "This library provides session handling middleware for PSR-7 applications, using\nan adapter-based approach that will allow usage of ext-session, JWT, or other\napproaches.",
            "title": "zend-expressive-session"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-session  However, the package is not immediately useful unless you have a persistence\nadapter. If you are okay with using ext-session, you can install the following\npackage as well:  $ composer require zendframework/zend-expressive-session-ext",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "zend-expressive-session\n\n\nWeb applications often need to persist user state between requests, and the\ngenerally accepted way to do so is via \nsessions\n. While PHP provides its own\nsession extension, it:\n\n\n\n\nuses global functions that affect global state.\n\n\nrelies on a superglobal for access to both read and write the session data.\n\n\nincurs either filesystem or network I/O on every request, depending on the\n  session storage handler.\n\n\ncan clobber the \nSet-Cookie\n header when other processes also set it.\n\n\n\n\nSome projects, such as \npsr-7-sessions/storageless\n,\ntake a different approach, using \nJSON Web Tokens\n (JWT).\n\n\nThe goals of zend-expressive-session are:\n\n\n\n\nto abstract the way users interact with session storage.\n\n\nto abstract how sessions are persisted, to allow both standard ext-session,\n  but also other paradigms such as JWT.\n\n\nto provide session capabilities that \"play nice\" with\n  \nPSR-7\n and middleware.\n\n\n\n\nInstallation\n\n\nUse \nComposer\n to install this package:\n\n\n$ composer require zendframework/zend-expressive-session\n\n\n\nHowever, the package is not immediately useful unless you have a persistence\nadapter. If you are okay with using ext-session, you can install the following\npackage as well:\n\n\n$ composer require zendframework/zend-expressive-session-ext\n\n\n\nFeatures\n\n\nzend-expressive-session provides the following:\n\n\n\n\nInterfaces for:\n\n\nsession containers\n\n\nsession persistence\n\n\n\n\n\n\nAn implementation of the session container.\n\n\nA \"lazy-loading\" implementation of the session container, to allow delaying\n  any de/serialization and/or I/O processes until session data is requested;\n  this implementation decorates a normal session container.\n\n\nPSR-7 middleware that:\n\n\ncomposes a session persistence implementation.\n\n\ninitializes the lazy-loading session container, using the session\n  persistence implementation.\n\n\ndelegates to the next middleware, passing the session container into the\n  request.\n\n\nfinalizes the session before returning the response.\n\n\n\n\n\n\n\n\nPersistence implementations locate session information from the requests (e.g.,\nvia a cookie) in order to initialize the session. On completion of the request,\nthey examine the session container for changes and/or to see if it is empty, and\nprovide data to the response so as to notify the client of the session (e.g.,\nvia a \nSet-Cookie\n header).\n\n\nNote that the goals of this package are solely focused on \nsession persistence\n\nand \naccess to session data by middleware\n. If you also need other features\noften related to session data, you may want to consider the following packages:\n\n\n\n\nzend-expressive-flash\n: \n  provides flash message capabilities.\n\n\nzend-expressive-csrf\n: \n  provides CSRF token generation, storage, and verification, using either a\n  session container, or flash messages.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#zend-expressive-session",
            "text": "Web applications often need to persist user state between requests, and the\ngenerally accepted way to do so is via  sessions . While PHP provides its own\nsession extension, it:   uses global functions that affect global state.  relies on a superglobal for access to both read and write the session data.  incurs either filesystem or network I/O on every request, depending on the\n  session storage handler.  can clobber the  Set-Cookie  header when other processes also set it.   Some projects, such as  psr-7-sessions/storageless ,\ntake a different approach, using  JSON Web Tokens  (JWT).  The goals of zend-expressive-session are:   to abstract the way users interact with session storage.  to abstract how sessions are persisted, to allow both standard ext-session,\n  but also other paradigms such as JWT.  to provide session capabilities that \"play nice\" with\n   PSR-7  and middleware.",
            "title": "zend-expressive-session"
        },
        {
            "location": "/intro/#installation",
            "text": "Use  Composer  to install this package:  $ composer require zendframework/zend-expressive-session  However, the package is not immediately useful unless you have a persistence\nadapter. If you are okay with using ext-session, you can install the following\npackage as well:  $ composer require zendframework/zend-expressive-session-ext",
            "title": "Installation"
        },
        {
            "location": "/intro/#features",
            "text": "zend-expressive-session provides the following:   Interfaces for:  session containers  session persistence    An implementation of the session container.  A \"lazy-loading\" implementation of the session container, to allow delaying\n  any de/serialization and/or I/O processes until session data is requested;\n  this implementation decorates a normal session container.  PSR-7 middleware that:  composes a session persistence implementation.  initializes the lazy-loading session container, using the session\n  persistence implementation.  delegates to the next middleware, passing the session container into the\n  request.  finalizes the session before returning the response.     Persistence implementations locate session information from the requests (e.g.,\nvia a cookie) in order to initialize the session. On completion of the request,\nthey examine the session container for changes and/or to see if it is empty, and\nprovide data to the response so as to notify the client of the session (e.g.,\nvia a  Set-Cookie  header).  Note that the goals of this package are solely focused on  session persistence \nand  access to session data by middleware . If you also need other features\noften related to session data, you may want to consider the following packages:   zend-expressive-flash : \n  provides flash message capabilities.  zend-expressive-csrf : \n  provides CSRF token generation, storage, and verification, using either a\n  session container, or flash messages.",
            "title": "Features"
        },
        {
            "location": "/session/",
            "text": "Session Containers\n\n\nSession containers are the primary interface with which most application\ndevelopers will work; they contain the data currently in the session, and allow\nyou to push data to the session.\n\n\nAll session containers implement \nZend\\Expressive\\Session\\SessionInterface\n:\n\n\nnamespace Zend\\Expressive\\Session;\n\ninterface SessionInterface\n{\n    /**\n     * Serialize the session data to an array for storage purposes.\n     */\n    public function toArray() : array;\n\n    /**\n     * Retrieve a value from the session.\n     *\n     * @param mixed $default Default value to return if $name does not exist.\n     * @return mixed\n     */\n    public function get(string $name, $default = null);\n\n    /**\n     * Whether or not the container has the given key.\n     */\n    public function has(string $name) : bool;\n\n    /**\n     * Set a value within the session.\n     *\n     * Values MUST be serializable in any format; we recommend ensuring the\n     * values are JSON serializable for greatest portability.\n     *\n     * @param mixed $value\n     */\n    public function set(string $name, $value) : void;\n\n    /**\n     * Remove a value from the session.\n     */\n    public function unset(string $name) : void;\n\n    /**\n     * Clear all values.\n     */\n    public function clear() : void;\n\n    /**\n     * Does the session contain changes? If not, the middleware handling\n     * session persistence may not need to do more work.\n     */\n    public function hasChanged() : bool;\n\n    /**\n     * Regenerate the session.\n     *\n     * This can be done to prevent session fixation. When executed, it SHOULD\n     * return a new instance; that instance should always return true for\n     * isRegenerated().\n     *\n     * An example of where this WOULD NOT return a new instance is within the\n     * shipped LazySession, where instead it would return itself, after\n     * internally re-setting the proxied session.\n     */\n    public function regenerate(): SessionInterface;\n\n    /**\n     * Method to determine if the session was regenerated; should return\n     * true if the instance was produced via regenerate().\n     */\n    public function isRegenerated() : bool;\n}\n\n\n\nThe default implementation, and the one you'll most likely interact with, is\n\nZend\\Expressive\\Session\\Session\n.\n\n\nSince version 1.1.0, we provide \nZend\\Expressive\\Session\\SessionIdentifierAwareInterface\n:\n\n\nnamespace Zend\\Expressive\\Session;\n\ninterface SessionIdentifierAwareInterface\n{\n    /**\n     * Retrieve the session identifier.\n     *\n     * This feature was added in 1.1.0 to allow the session persistence to be\n     * stateless. Previously, persistence implementations had to store the\n     * session identifier between calls to initializeSessionFromRequest() and\n     * persistSession(). When SessionInterface implementations also implement\n     * this method, the persistence implementation no longer needs to store it.\n     *\n     * This method will become a part of the SessionInterface in 2.0.0.\n     *\n     * @since 1.1.0\n     */\n    public function getId() : string;\n}\n\n\n\nSince version 1.2.0, we provide \nZend\\Expressive\\Session\\SessionCookiePersistenceInterface\n:\n\n\nnamespace Zend\\Expressive\\Session;\n\n/**\n * Allow marking session cookies as persistent.\n *\n * It can be useful to mark a session as persistent: e.g., for a \"Remember Me\"\n * feature when logging a user into your system. PHP provides this capability\n * via ext-session with the $lifetime argument to session_set_cookie_params()\n * as well as by the session.cookie_lifetime INI setting. The latter will set\n * the value for all session cookies sent (or until the value is changed via\n * an ini_set() call), while the former will only affect cookies created during\n * the current script lifetime.\n *\n * Persistence engines may, of course, allow setting a global lifetime. This\n * interface allows developers to set the lifetime programmatically. Persistence\n * implementations are encouraged to use the value to set the cookie lifetime\n * when creating and returning a cookie. Additionally, to ensure the cookie\n * lifetime originally requested is honored when a session is regenerated, we\n * recommend persistence engines to store the TTL in the session data itself,\n * so that it can be re-sent in such scenarios.\n */\ninterface SessionCookiePersistenceInterface\n{\n    const SESSION_LIFETIME_KEY = '__SESSION_TTL__';\n\n    /**\n     * Define how long the session cookie should live.\n     *\n     * Use this value to detail to the session persistence engine how long the\n     * session cookie should live.\n     *\n     * This value could be passed as the $lifetime value of\n     * session_set_cookie_params(), or used to create an Expires or Max-Age\n     * parameter for a session cookie.\n     *\n     * Since cookie lifetime is communicated by the server to the client, and\n     * not vice versa, the value should likely be persisted in the session\n     * itself, to ensure that session regeneration uses the same value. We\n     * recommend using the SESSION_LIFETIME_KEY value to communicate this.\n     *\n     * @param int $duration Number of seconds the cookie should persist for.\n     */\n    public function persistSessionFor(int $duration) : void;\n\n    /**\n     * Determine how long the session cookie should live.\n     *\n     * Generally, this will return the value provided to persistFor().\n     *\n     * If that method has not been called, the value can return one of the\n     * following:\n     *\n     * - 0 or a negative value, to indicate the cookie should be treated as a\n     *   session cookie, and expire when the window is closed. This should be\n     *   the default behavior.\n     * - If persistFor() was provided during session creation or anytime later,\n     *   the persistence engine should pull the TTL value from the session itself\n     *   and return it here. Typically, this value should be communicated via\n     *   the SESSION_LIFETIME_KEY value of the session.\n     */\n    public function getSessionLifetime() : int;\n}\n\n\n\nZend\\Expressive\\Session\\Session\n and \nZend\\Expressive\\Session\\LazySession\n both\nimplement each of the interfaces listed above. \nSession\n accepts an optional\nidentifier to its constructor, and will use the value of the\n\nSessionCookiePersistenceInterface::SESSION_LIFETIME_KEY\n in the provided data\nto seed the session cookie lifetime, if present.\n\n\nUsage\n\n\nSession containers will typically be passed to your middleware using the\n\nSessionMiddleware\n, via the\n\nZend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE\n (\"session\")\nrequest attribute.\n\n\nOnce you have the container, you can check for data:\n\n\nif ($session->has('user')) {\n}\n\n\n\nand retrieve it:\n\n\n$user = $session->get('user');\n\n\n\nYou can combine those operations, by passing a default value as a second\nargument to the \nget()\n method:\n\n\n$user = $session->get('user', new GuestUser());\n\n\n\nIf a datum is no longer relevant in the session, \nunset()\n it:\n\n\n$session->unset('user');\n\n\n\nIf none of the data is relevant, \nclear()\n the session:\n\n\n$session->clear();\n\n\n\nPersistent Sessions\n\n\n\n\nSince 1.2.0\n\n\n\n\nYou can hint to the session persistence engine how long the session should\npersist:\n\n\n$session->persistSessionFor(60 * 60 * 24 * 7); // persist for 7 days\n\n\n\nTo make the session expire when the browser session is terminated (default\nbehavior), use zero or a negative integer:\n\n\n$session->persistSessionFor(0); // expire data after session is over\n\n\n\nLazy Sessions\n\n\nThis package provides another implementation of \nSessionInterface\n via\n\nZend\\Expressive\\Session\\LazySession\n. This implementation does the following:\n\n\n\n\nIt composes a \npersistence\n instance, along with the current\n  request.\n\n\nOn \nfirst access\n (e.g., \nget()\n, \nset()\n, etc.), it uses the composed\n  persistence and request instances to generate the \nactual\n session container.\n  All methods then \nproxy\n to this container.\n\n\n\n\nThis approach helps delay any I/O or network operations, and/or\ndeserialization, until they are actually needed.\n\n\nThe shipped \nSessionMiddleware\n produces a \nLazySession\n.\n\n\nSession Regeneration\n\n\nSome application events benefit from \nsession regeneration\n. In particular,\nafter a user has successfully logged in or out, you will generally want to\nregenerate the session in order to prevent session fixation and the attack\nvectors it invites.\n\n\nIn those situations, call \nregenerate()\n:\n\n\n$newSession = $session->regenerate();\n\n\n\nThe interface indicates that a new instance \nshould\n be returned. However, in\nthe default usage, you will have a \nLazySession\n instance (as described above),\nwhich \ndecorates\n the underlying session storage. This is done for two reasons:\n\n\n\n\nFirst, the stated reasons of preventing the need to deserialize data and/or\n  perform I/O access until the last moment.\n\n\nSecond, to ensure that the \nSessionMiddleware\n \nalways has a pointer to the\n  session\n.\n\n\n\n\nThis latter is what allows you to regenerate the session in middleware nested\ndeep in your application, but still have the data persisted correctly.",
            "title": "Session Containers"
        },
        {
            "location": "/session/#session-containers",
            "text": "Session containers are the primary interface with which most application\ndevelopers will work; they contain the data currently in the session, and allow\nyou to push data to the session.  All session containers implement  Zend\\Expressive\\Session\\SessionInterface :  namespace Zend\\Expressive\\Session;\n\ninterface SessionInterface\n{\n    /**\n     * Serialize the session data to an array for storage purposes.\n     */\n    public function toArray() : array;\n\n    /**\n     * Retrieve a value from the session.\n     *\n     * @param mixed $default Default value to return if $name does not exist.\n     * @return mixed\n     */\n    public function get(string $name, $default = null);\n\n    /**\n     * Whether or not the container has the given key.\n     */\n    public function has(string $name) : bool;\n\n    /**\n     * Set a value within the session.\n     *\n     * Values MUST be serializable in any format; we recommend ensuring the\n     * values are JSON serializable for greatest portability.\n     *\n     * @param mixed $value\n     */\n    public function set(string $name, $value) : void;\n\n    /**\n     * Remove a value from the session.\n     */\n    public function unset(string $name) : void;\n\n    /**\n     * Clear all values.\n     */\n    public function clear() : void;\n\n    /**\n     * Does the session contain changes? If not, the middleware handling\n     * session persistence may not need to do more work.\n     */\n    public function hasChanged() : bool;\n\n    /**\n     * Regenerate the session.\n     *\n     * This can be done to prevent session fixation. When executed, it SHOULD\n     * return a new instance; that instance should always return true for\n     * isRegenerated().\n     *\n     * An example of where this WOULD NOT return a new instance is within the\n     * shipped LazySession, where instead it would return itself, after\n     * internally re-setting the proxied session.\n     */\n    public function regenerate(): SessionInterface;\n\n    /**\n     * Method to determine if the session was regenerated; should return\n     * true if the instance was produced via regenerate().\n     */\n    public function isRegenerated() : bool;\n}  The default implementation, and the one you'll most likely interact with, is Zend\\Expressive\\Session\\Session .  Since version 1.1.0, we provide  Zend\\Expressive\\Session\\SessionIdentifierAwareInterface :  namespace Zend\\Expressive\\Session;\n\ninterface SessionIdentifierAwareInterface\n{\n    /**\n     * Retrieve the session identifier.\n     *\n     * This feature was added in 1.1.0 to allow the session persistence to be\n     * stateless. Previously, persistence implementations had to store the\n     * session identifier between calls to initializeSessionFromRequest() and\n     * persistSession(). When SessionInterface implementations also implement\n     * this method, the persistence implementation no longer needs to store it.\n     *\n     * This method will become a part of the SessionInterface in 2.0.0.\n     *\n     * @since 1.1.0\n     */\n    public function getId() : string;\n}  Since version 1.2.0, we provide  Zend\\Expressive\\Session\\SessionCookiePersistenceInterface :  namespace Zend\\Expressive\\Session;\n\n/**\n * Allow marking session cookies as persistent.\n *\n * It can be useful to mark a session as persistent: e.g., for a \"Remember Me\"\n * feature when logging a user into your system. PHP provides this capability\n * via ext-session with the $lifetime argument to session_set_cookie_params()\n * as well as by the session.cookie_lifetime INI setting. The latter will set\n * the value for all session cookies sent (or until the value is changed via\n * an ini_set() call), while the former will only affect cookies created during\n * the current script lifetime.\n *\n * Persistence engines may, of course, allow setting a global lifetime. This\n * interface allows developers to set the lifetime programmatically. Persistence\n * implementations are encouraged to use the value to set the cookie lifetime\n * when creating and returning a cookie. Additionally, to ensure the cookie\n * lifetime originally requested is honored when a session is regenerated, we\n * recommend persistence engines to store the TTL in the session data itself,\n * so that it can be re-sent in such scenarios.\n */\ninterface SessionCookiePersistenceInterface\n{\n    const SESSION_LIFETIME_KEY = '__SESSION_TTL__';\n\n    /**\n     * Define how long the session cookie should live.\n     *\n     * Use this value to detail to the session persistence engine how long the\n     * session cookie should live.\n     *\n     * This value could be passed as the $lifetime value of\n     * session_set_cookie_params(), or used to create an Expires or Max-Age\n     * parameter for a session cookie.\n     *\n     * Since cookie lifetime is communicated by the server to the client, and\n     * not vice versa, the value should likely be persisted in the session\n     * itself, to ensure that session regeneration uses the same value. We\n     * recommend using the SESSION_LIFETIME_KEY value to communicate this.\n     *\n     * @param int $duration Number of seconds the cookie should persist for.\n     */\n    public function persistSessionFor(int $duration) : void;\n\n    /**\n     * Determine how long the session cookie should live.\n     *\n     * Generally, this will return the value provided to persistFor().\n     *\n     * If that method has not been called, the value can return one of the\n     * following:\n     *\n     * - 0 or a negative value, to indicate the cookie should be treated as a\n     *   session cookie, and expire when the window is closed. This should be\n     *   the default behavior.\n     * - If persistFor() was provided during session creation or anytime later,\n     *   the persistence engine should pull the TTL value from the session itself\n     *   and return it here. Typically, this value should be communicated via\n     *   the SESSION_LIFETIME_KEY value of the session.\n     */\n    public function getSessionLifetime() : int;\n}  Zend\\Expressive\\Session\\Session  and  Zend\\Expressive\\Session\\LazySession  both\nimplement each of the interfaces listed above.  Session  accepts an optional\nidentifier to its constructor, and will use the value of the SessionCookiePersistenceInterface::SESSION_LIFETIME_KEY  in the provided data\nto seed the session cookie lifetime, if present.",
            "title": "Session Containers"
        },
        {
            "location": "/session/#usage",
            "text": "Session containers will typically be passed to your middleware using the SessionMiddleware , via the Zend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE  (\"session\")\nrequest attribute.  Once you have the container, you can check for data:  if ($session->has('user')) {\n}  and retrieve it:  $user = $session->get('user');  You can combine those operations, by passing a default value as a second\nargument to the  get()  method:  $user = $session->get('user', new GuestUser());  If a datum is no longer relevant in the session,  unset()  it:  $session->unset('user');  If none of the data is relevant,  clear()  the session:  $session->clear();",
            "title": "Usage"
        },
        {
            "location": "/session/#persistent-sessions",
            "text": "Since 1.2.0   You can hint to the session persistence engine how long the session should\npersist:  $session->persistSessionFor(60 * 60 * 24 * 7); // persist for 7 days  To make the session expire when the browser session is terminated (default\nbehavior), use zero or a negative integer:  $session->persistSessionFor(0); // expire data after session is over",
            "title": "Persistent Sessions"
        },
        {
            "location": "/session/#lazy-sessions",
            "text": "This package provides another implementation of  SessionInterface  via Zend\\Expressive\\Session\\LazySession . This implementation does the following:   It composes a  persistence  instance, along with the current\n  request.  On  first access  (e.g.,  get() ,  set() , etc.), it uses the composed\n  persistence and request instances to generate the  actual  session container.\n  All methods then  proxy  to this container.   This approach helps delay any I/O or network operations, and/or\ndeserialization, until they are actually needed.  The shipped  SessionMiddleware  produces a  LazySession .",
            "title": "Lazy Sessions"
        },
        {
            "location": "/session/#session-regeneration",
            "text": "Some application events benefit from  session regeneration . In particular,\nafter a user has successfully logged in or out, you will generally want to\nregenerate the session in order to prevent session fixation and the attack\nvectors it invites.  In those situations, call  regenerate() :  $newSession = $session->regenerate();  The interface indicates that a new instance  should  be returned. However, in\nthe default usage, you will have a  LazySession  instance (as described above),\nwhich  decorates  the underlying session storage. This is done for two reasons:   First, the stated reasons of preventing the need to deserialize data and/or\n  perform I/O access until the last moment.  Second, to ensure that the  SessionMiddleware   always has a pointer to the\n  session .   This latter is what allows you to regenerate the session in middleware nested\ndeep in your application, but still have the data persisted correctly.",
            "title": "Session Regeneration"
        },
        {
            "location": "/persistence/",
            "text": "Session Persistence\n\n\nSession persistence within zend-expressive-session refers to one or both of the\nfollowing:\n\n\n\n\nIdentifying session information provided by the client making the request.\n\n\nStoring session data for access on subsequent requests.\n\n\nProviding session information to the client making the request.\n\n\n\n\nIn some scenarios, such as usage of JSON Web Tokens (JWT), the serialized\nsession data is provided \nby\n the client, and provided \nto\n the client directly,\nwithout any server-side storage whatsoever.\n\n\nTo describe these operations, we provide \nZend\\Expressive\\Session\\SessionPersistenceInterface\n:\n\n\nnamespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface SessionPersistenceInterface\n{\n    /**\n     * Generate a session data instance based on the request.\n     */\n    public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface;\n\n    /**\n     * Persist the session data instance.\n     *\n     * Persists the session data, returning a response instance with any\n     * artifacts required to return to the client.\n     */\n    public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface;\n}\n\n\n\nSession initialization pulls data from the request (a cookie, a header value,\netc.) in order to produce a session container. Session persistence pulls data\nfrom the session container, does something with it, and then optionally provides\na response containing session artifacts (a cookie, a header value, etc.).\n\n\nFor sessions to work, \nyou must provide a persistence implementation\n. We\nprovide one such implementation using PHP's session extension via the package\n\nzend-expressive-session-ext\n.\n\n\nSession identifiers\n\n\nTypically, the session identifier will be retrieved from the request (usually\nvia a cookie), and a new identifier created if none was discovered.\n\n\nDuring persistence, if an existing session's contents have changed, or\n\nregenerateId()\n was called on the session, the persistence implementation\nbecomes responsible for:\n\n\n\n\nRemoving the original session.\n\n\nGenerating a new identifier for the session.\n\n\n\n\nIn all situations, it then needs to store the session data in such a way that a\nlater lookup by the current identifier will retrieve that data.\n\n\nPrior to version 1.1.0, persistence engines had two ways to determine what the\noriginal session identifier was when it came time to regenerate or persist a\nsession:\n\n\n\n\nStore the identifier as a property of the persistence implementation.\n\n\nStore the identifier in the session data under a \"magic\" key (e.g.,\n  \n__SESSION_ID__\n).\n\n\n\n\nThe first approach is problematic when using zend-expressive-session in an async\nenvironment such as \nSwoole\n or\n\nReactPHP\n, as the same persistence instance may be used\nby several simultaneous requests. As such, version 1.1.0 introduces a new\ninterface for \nZend\\Expressive\\Session\\SessionInterface\n implementations to use:\n\nZend\\Expressive\\Session\\SessionIdentifierAwareInterface\n. This interface\ndefines a single method, \ngetId()\n; implementations can thus store the\nidentifier internally, and, when it comes time to store the session data,\npersistence implementations can query that method in order to retrieve the\nsession identifier.\n\n\nConsidering that persistence implementations also \ncreate\n the session instance,\nwe recommend that implementations only create instances that implement the\n\nSessionIdentifierAwareInterface\n going forward in order to make themselves\nasync compatible.\n\n\nPersistent sessions\n\n\n\n\nSince 1.2.0.\n\n\n\n\nIf your persistence implementation supports persistent sessions \u2014 for\nexample, by setting an \nExpires\n or \nMax-Age\n cookie directive \u2014 then you\ncan opt to globally set a default session duration, or allow developers to hint\na desired session duration via the session container using\n\nSessionContainerPersistenceInterface::persistSessionFor()\n.\n\n\nImplementations SHOULD honor the value of \nSessionContainerPersistenceInterface::getSessionLifetime()\n\nwhen persisting the session data. This could mean either or both of the\nfollowing:\n\n\n\n\nEnsuring that the session data will not be purged until after the specified\n  TTL value.\n\n\nSetting an \nExpires\n or \nMax-Age\n cookie directive.\n\n\n\n\nIn each case, the persistence engine should query the \nSession\n instance for a\nTTL value:\n\n\n$ttl = $session instanceof SessionContainerPersistenceInterface\n    ? $session->getSessionLifetime()\n    : $defaultLifetime; // likely 0, to indicate automatic expiry\n\n\n\ngetSessionLifetime()\n returns an \ninteger\n value indicating the number of\nseconds the session should persist.",
            "title": "Session Persistence"
        },
        {
            "location": "/persistence/#session-persistence",
            "text": "Session persistence within zend-expressive-session refers to one or both of the\nfollowing:   Identifying session information provided by the client making the request.  Storing session data for access on subsequent requests.  Providing session information to the client making the request.   In some scenarios, such as usage of JSON Web Tokens (JWT), the serialized\nsession data is provided  by  the client, and provided  to  the client directly,\nwithout any server-side storage whatsoever.  To describe these operations, we provide  Zend\\Expressive\\Session\\SessionPersistenceInterface :  namespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface SessionPersistenceInterface\n{\n    /**\n     * Generate a session data instance based on the request.\n     */\n    public function initializeSessionFromRequest(ServerRequestInterface $request) : SessionInterface;\n\n    /**\n     * Persist the session data instance.\n     *\n     * Persists the session data, returning a response instance with any\n     * artifacts required to return to the client.\n     */\n    public function persistSession(SessionInterface $session, ResponseInterface $response) : ResponseInterface;\n}  Session initialization pulls data from the request (a cookie, a header value,\netc.) in order to produce a session container. Session persistence pulls data\nfrom the session container, does something with it, and then optionally provides\na response containing session artifacts (a cookie, a header value, etc.).  For sessions to work,  you must provide a persistence implementation . We\nprovide one such implementation using PHP's session extension via the package zend-expressive-session-ext .",
            "title": "Session Persistence"
        },
        {
            "location": "/persistence/#session-identifiers",
            "text": "Typically, the session identifier will be retrieved from the request (usually\nvia a cookie), and a new identifier created if none was discovered.  During persistence, if an existing session's contents have changed, or regenerateId()  was called on the session, the persistence implementation\nbecomes responsible for:   Removing the original session.  Generating a new identifier for the session.   In all situations, it then needs to store the session data in such a way that a\nlater lookup by the current identifier will retrieve that data.  Prior to version 1.1.0, persistence engines had two ways to determine what the\noriginal session identifier was when it came time to regenerate or persist a\nsession:   Store the identifier as a property of the persistence implementation.  Store the identifier in the session data under a \"magic\" key (e.g.,\n   __SESSION_ID__ ).   The first approach is problematic when using zend-expressive-session in an async\nenvironment such as  Swoole  or ReactPHP , as the same persistence instance may be used\nby several simultaneous requests. As such, version 1.1.0 introduces a new\ninterface for  Zend\\Expressive\\Session\\SessionInterface  implementations to use: Zend\\Expressive\\Session\\SessionIdentifierAwareInterface . This interface\ndefines a single method,  getId() ; implementations can thus store the\nidentifier internally, and, when it comes time to store the session data,\npersistence implementations can query that method in order to retrieve the\nsession identifier.  Considering that persistence implementations also  create  the session instance,\nwe recommend that implementations only create instances that implement the SessionIdentifierAwareInterface  going forward in order to make themselves\nasync compatible.",
            "title": "Session identifiers"
        },
        {
            "location": "/persistence/#persistent-sessions",
            "text": "Since 1.2.0.   If your persistence implementation supports persistent sessions \u2014 for\nexample, by setting an  Expires  or  Max-Age  cookie directive \u2014 then you\ncan opt to globally set a default session duration, or allow developers to hint\na desired session duration via the session container using SessionContainerPersistenceInterface::persistSessionFor() .  Implementations SHOULD honor the value of  SessionContainerPersistenceInterface::getSessionLifetime() \nwhen persisting the session data. This could mean either or both of the\nfollowing:   Ensuring that the session data will not be purged until after the specified\n  TTL value.  Setting an  Expires  or  Max-Age  cookie directive.   In each case, the persistence engine should query the  Session  instance for a\nTTL value:  $ttl = $session instanceof SessionContainerPersistenceInterface\n    ? $session->getSessionLifetime()\n    : $defaultLifetime; // likely 0, to indicate automatic expiry  getSessionLifetime()  returns an  integer  value indicating the number of\nseconds the session should persist.",
            "title": "Persistent sessions"
        },
        {
            "location": "/middleware/",
            "text": "Session Middleware\n\n\nzend-expressive-session provides middleware consuming\n\nPSR-7\n HTTP message instances, via\nimplementation of \nPSR-15\n\ninterfaces.\n\n\nThis middleware composes a \npersistence\n instance, and uses that\nin order to generate a session container, which it pushes into the request it\ndelegates to the next middleware. Once a response is returned, it uses the\npersistence instance to persist the session data and provide information back to\nthe client.\n\n\nThe above two paragraphs are longer than the body of the middleware\nimplementation:\n\n\nnamespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass SessionMiddleware implements MiddlewareInterface\n{\n    public const SESSION_ATTRIBUTE = 'session';\n\n    private $persistence;\n\n    public function __construct(SessionPersistenceInterface $persistence)\n    {\n        $this->persistence = $persistence;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $session = new LazySession($this->persistence, $request);\n        $response = $handler->handle($request->withAttribute(self::SESSION_ATTRIBUTE, $session));\n        return $this->persistence->persistSession($session, $response);\n    }\n}\n\n\n\nConfiguration\n\n\nThis package provides a factory for \nZend\\Expressive\\Session\\SessionMiddleware\n\nvia \nZend\\Expressive\\Session\\SessionMiddlewareFactory\n; this factory is\nauto-wired if you are using Expressive and the zend-component-installer Composer\nplugin. If not, you will need to wire these into your application.\n\n\nThe factory depends on one service: \nZend\\Expressive\\Session\\SessionPersistenceInterface\n.\nYou will need to either wire in your persistence implementation of choice, or\nhave the package providing it do so for you.\n\n\nAdding the middleware to your application\n\n\nYou may pipe this middleware anywhere in your application. If you want to have\nit available anywhere, pipe it early in your application, prior to any routing.\nAs an example, within Expressive, you could pipe it in the \nconfig/pipeline.php\n\nfile:\n\n\n$app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipeRoutingMiddleware();\n\n\n\nThis will generally be an inexpensive operation; since the middleware uses a\n\nLazySession\n instance, unless your persistence implementation does any work in\nits constructor, the cost is just that of instantiating a few objects.\n\n\nHowever, it's often useful to specifically include such middleware directly in\nthe routed middleware pipelines, to ensure other developers are aware of its\npresence in that route's workflow.\n\n\nWithin Expressive, you can do this when routing, in your \nconfig/routes.php\n\nfile, or within a \ndelegator factory\n:\n\n\n$app->post('/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\User\\Middleware\\LoginHandler::class\n]);",
            "title": "Session Middleware"
        },
        {
            "location": "/middleware/#session-middleware",
            "text": "zend-expressive-session provides middleware consuming PSR-7  HTTP message instances, via\nimplementation of  PSR-15 \ninterfaces.  This middleware composes a  persistence  instance, and uses that\nin order to generate a session container, which it pushes into the request it\ndelegates to the next middleware. Once a response is returned, it uses the\npersistence instance to persist the session data and provide information back to\nthe client.  The above two paragraphs are longer than the body of the middleware\nimplementation:  namespace Zend\\Expressive\\Session;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass SessionMiddleware implements MiddlewareInterface\n{\n    public const SESSION_ATTRIBUTE = 'session';\n\n    private $persistence;\n\n    public function __construct(SessionPersistenceInterface $persistence)\n    {\n        $this->persistence = $persistence;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $session = new LazySession($this->persistence, $request);\n        $response = $handler->handle($request->withAttribute(self::SESSION_ATTRIBUTE, $session));\n        return $this->persistence->persistSession($session, $response);\n    }\n}",
            "title": "Session Middleware"
        },
        {
            "location": "/middleware/#configuration",
            "text": "This package provides a factory for  Zend\\Expressive\\Session\\SessionMiddleware \nvia  Zend\\Expressive\\Session\\SessionMiddlewareFactory ; this factory is\nauto-wired if you are using Expressive and the zend-component-installer Composer\nplugin. If not, you will need to wire these into your application.  The factory depends on one service:  Zend\\Expressive\\Session\\SessionPersistenceInterface .\nYou will need to either wire in your persistence implementation of choice, or\nhave the package providing it do so for you.",
            "title": "Configuration"
        },
        {
            "location": "/middleware/#adding-the-middleware-to-your-application",
            "text": "You may pipe this middleware anywhere in your application. If you want to have\nit available anywhere, pipe it early in your application, prior to any routing.\nAs an example, within Expressive, you could pipe it in the  config/pipeline.php \nfile:  $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipeRoutingMiddleware();  This will generally be an inexpensive operation; since the middleware uses a LazySession  instance, unless your persistence implementation does any work in\nits constructor, the cost is just that of instantiating a few objects.  However, it's often useful to specifically include such middleware directly in\nthe routed middleware pipelines, to ensure other developers are aware of its\npresence in that route's workflow.  Within Expressive, you can do this when routing, in your  config/routes.php \nfile, or within a  delegator factory :  $app->post('/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\User\\Middleware\\LoginHandler::class\n]);",
            "title": "Adding the middleware to your application"
        }
    ]
}